#/usr/bin/env bash
set -eu

# Usage:
#    run-clang-tidy [normal|test]
#
# Options:
#    normal   : If specified, run clang-tidy on *.cc files except test files (warnings are treated as errors)
#    test     : If specified, run clang-tidy on *_test.cc files (warnings are ignored)
#
# Notes:
# - This script must be run from the build directory, in which compile_commands.json exits.
#   compile_commands.json is generated by cmake.
# - clang-tidy accepts relative paths from build directory for source files.
#   rel_source_dir is such relative path of the source root directory (xchainer/).

script_dir="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
root_dir="$(realpath "$script_dir"/..)"
source_dir="$root_dir"/xchainer
build_dir="$(realpath $PWD)"
rel_source_dir="$(python -c 'import os; print(os.path.relpath("'$source_dir'", "'$build_dir'"))')"

if [ $# != 1 ]; then
    echo "Too many or too few arguments." >&2
    exit 1
fi

target="$1"

if [ "$target" != "normal" -a "$target" != "test" ]; then
    echo "Specify either 'normal' or 'test'." >&2
    exit 1
fi


# Check if there is compile_commands.json in the current directory.
if [ ! -f "compile_commands.json" ]; then
    echo "compile_commands.json is not found in the current directory." >&2
    exit 1
fi

# find_command: find command to search for source files
# grep_regex: Regex expression to search for error (or warning) lines

if [ "$target" == "normal" ]; then
    find_command=(find "$rel_source_dir" -name "*.cc" -not -name "*_test.cc" -print0)
    # TODO(niboshi): report warnings too by replacing with the next line.
    #grep_regex="^[^ ]+: (warning|error): .*"
    grep_regex="^[^ ]+: error: .*"

else
    find_command=(find "$rel_source_dir" -name "*_test.cc" -print0)
    grep_regex="^[^ ]+: error: .*"
fi

# Run clang-tidy.
# xargs can split into multiple invocations of clang-tidy depending on the number of input files.
# Currently it does not cause a problem because the awk script simply counts the matching lines line-by-line.
# Keep that in mind when the script is to be modified.
error=0
"${find_command[@]}" | xargs -0 clang-tidy | awk '
    { print }
    /'"$grep_regex"'/ { n = n == 255 ? 255 : n+1 }
    END { exit n }' || error=$?

# If xargs fails, return the maximum possible number
if [ ${PIPESTATUS[1]} != 0 ]; then
    exit 255
fi

# Report the number of errors
exit "$error"
