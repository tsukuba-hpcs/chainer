Create your own trainer extension
=================================

.. currentmodule:: chainer

In this section, you will learn about the following things:

- :ref:`basic`
- How to create your own trainer extension

    * :ref:`by defining a simple function<function>`
    * :ref:`by defining a function decorated with @make_extension <decorator>`
    * :ref:`by defining a class inherited from Extension class <class>`

.. _basic:

What is trainer Extension?
--------------------------

:class:`~chainer.training.Extension` is a callable object that takes a :class:`~chainer.training.Trainer` object as an argument. Adding an :class:`~chainer.training.Extension` to a :class:`~chainer.training.Trainer` using :meth:`~chainer.training.Trainer.extend` method, the :class:`~chainer.training.Extension` will be called at given timing you specified by using ``trigger`` object (See the details in :ref:`trigger`)

A :class:`~chainer.training.Trainer` object has all information used in a training loop, e.g., models, optimizers, updaters, iterators, and datasets, etc. So you can change the settings of optimizers


.. _function:

Write a simple function
-----------------------

You can make a new :class:`~chainer.training.Extension` by writing a simple function which takes :class:`~chainer.training.Trainer` object as its argument. For example, when you want to reduce the learning rate at specified timing during training, ``lr_drop`` extension can be written as follows:

.. testcode::

    def lr_drop(trainer):
        trainer.updater.get_optimizer('main').lr *= 0.1

Then you can add this function to a :class:`~chainer.training.Trainer` object via :meth:`~chainer.training.Trainer.extend` method.

.. code-block:: python

    trainer.extend(lr_drop, trigger=(10, 'epoch'))

It performs learning rate dropping at every 10 epochs by multiplying 0.1 with the current learning rate.

.. _decorator:

Write a function decorated with @make_extension
-----------------------------------------------

:meth:`~chainer.training.make_extension` is a decorator that adds some attributes to a given function. For example, the simple extension we created above can be written in this form:

.. testcode::

    @make_extension(trigger=(10, 'epoch'))
    def lr_drop(trainer):
        trainer.updater.get_optimizer('main').lr *= 0.1

The difference between the above one and this is whether it has a default ``trigger`` or not. In this latter case, :meth:`lr_drop` has its default ``trigger`` so that unless another ``trigger`` is specified via :meth:`~chainer.training.Trainer.extend` method, the ``trigger`` specified in :meth:`~chainer.training.make_extension` is used as default. So the code below acts the same as the former example, i.e., it reduces the learning rate at every 10 epochs.

.. code_block:: python

    trainer.extend(lr_drop)

There are several attributes you can add using the :meth:`~chainer.training.make_extension` decorator.

.. _trigger:

1. trigger
^^^^^^^^^^

``trigger`` is an object that takes a :class:`~chainer.training.Trainer` object as an argument and returns a boolean value. If a tuple in a form ``(period, unit)`` is given as a trigger, it will be considered as an :class:`~chainer.training.triggers.IntervalTrigger` that invokes the extension at every ``period`` ``unit``. For example, when the given tuple is ``(10, 'epoch')``, the extension will be fired at every 10 epochs.

``trigger`` can also be given to the :meth:`~chainer.training.trainer.extend` method that adds an extension to a :class:`~chainer.training.Trainer` object. The priority of ``trigger``\ s is as follows:

- When both :meth:`~chainer.training.Trainer.extend` and a given :class:`~chainer.training.Extension` have ``trigger``\ s, the ``trigger`` given to :meth:`~chainer.training.Trainer.extend` is used.
- When ``None`` is given to :meth:`~chainer.training.Trainer.extend` as the ``trigger`` argument and a given :class:`~chainer.training.Extension` has ``trigger``, the ``trigger`` given to the :class:`~chainer.training.Extension` is used.
- When both ``trigger`` attributes in :meth:`~chainer.training.Trainer.extend` and :class:`~chainer.training.Extension` are ``None``, the :class:`~chainer.training.Extension` will be fired at every iteration.

See the details in the documentation of :meth:`~chainer.training.get_trigger`.

2. default_name
^^^^^^^^^^^^^^^

An :class:`~chainer.training.Extension` is kept in a dictionary which is a property in a :class:`~chainer.training.Trainer`. This argument gives the name of the :class:`~chainer.training.Extension`. Users will see this name in keys of the snapshot which is a dictionary generated by serialization.

3. priority
^^^^^^^^^^^

The priority that is used to determine the order of execution of extensions in a :class:`~chainer.training.Trainer` object. There are three standard values for the priorities:

- :data:`~chainer.training.extension.PRIORITY_WRITER`: The priority for extensions that write some records to the observation dictionary. It includes cases that the extension directly adds values to the observation dictionary, or the extension uses the chainer.report() function to report values to the observation dictionary. Extensions which write something to reporter should go first because the other Extensions which read those values could be added.
- :data:`~chainer.training.extension.PRIORITY_EDITOR`: The priority for extensions that edit the observation dictionary based on already reported values. Extensions which edit some values of reported ones should go after the extensions which write values to reporter but before extensions which read the final values.
- :data:`~chainer.training.extension.PRIORITY_READER`: The priority for extensions that only read records from the observation dictionary. This is also suitable for extensions that do not use the observation dictionary at all. Extensions which read the reported values should be fired after all the extensions which have other priorities, e.g, :data:`PRIORITY_WRITER` and :data:`PRIORITY_EDITOR` because it should read the final values.

See the details in the documentation of :class:`~chainer.training.Trainer`.

4. finalizer
^^^^^^^^^^^^

You can specify a function which takes :class:`~chainer.training.Trainer` object to finalize the extension. It is called once at the end of the whole training loops, namely, the :meth:`~chainer.training.Trainer.run` finished.

5. initializer
^^^^^^^^^^^^^^

You can specify a function which takes :class:`~chainer.training.Trainer` object to initialize the extension. It is called once at the beginning of the training loop, namely, before starting the actual loop.

.. _class:

Write a class inherited from Extension class
--------------------------------------------

This is the way to define your own extension with the maximum degree of freedom. You can keep any values inside of the extension and serialize them.
