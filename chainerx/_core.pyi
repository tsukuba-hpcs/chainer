from typing import Any
from typing import Callable
from typing import List
from typing import Optional
from typing import Sequence
from typing import Tuple
from typing import Union
from typing import overload

from chainer import function_node
import numpy


# python/backend.cc
class Backend:
    @property
    def context(self) -> Context: ...

    @property
    def name(self) -> str: ...

    def get_device(self, index: int) -> Device: ...

    def get_device_count(self) -> int: ...


# python/backprop_mode.cc
class NoBackpropMode:
    def __enter__(self) -> None: ...

    def __exit__(self, *args) -> None: ...


class ForceBackpropMode:
    def __enter__(self) -> None: ...

    def __exit__(self, *args) -> None: ...


@overload
def no_backprop_mode(backprop_id: BackpropId) -> NoBackpropMode: ...

@overload
def no_backprop_mode(backprop_id: List[BackpropId]) -> NoBackpropMode: ...

@overload
def no_backprop_mode(context: Optional[Context]=None) -> NoBackpropMode: ...

@overload
def force_backprop_mode(backprop_id: BackpropId) -> ForceBackpropMode: ...

@overload
def force_backprop_mode(backprop_id: List[BackpropId]) -> ForceBackpropMode: ...

@overload
def force_backprop_mode(context: Context=None) -> ForceBackpropMode: ...

@overload
def is_backprop_required(backprop_id: BackpropId) -> bool: ...

@overload
def is_backprop_required(context: Optional[Context]=None) -> bool: ...


# python/backward.cc
@overload
def backward(
        outputs: ndarray,
        backprop_id: Optional[BackpropId]=None,
        enable_double_backprop: bool=False) -> None: ...

@overload
def backward(
        outputs: List[ndarray],
        backprop_id: Optional[BackpropId]=None,
        enable_double_backprop: bool=False) -> None: ...


# python/check_backward.cc
def check_backward(
        func: Callable[[ndarray], None],
        inputs: List[ndarray],
        grad_outputs: List[ndarray],
        eps: List[ndarray],
        atol: float=...,
        rtol: float=...,
        backprop_id: Optional[BackpropId]=None) -> None: ...

def check_double_backward(
        func: Callable[[ndarray], None],
        inputs: List[ndarray],
        grad_outputs: List[ndarray],
        grad_grad_inputs: List[ndarray],
        eps: List[ndarray],
        atol: float=...,
        rtol: float=...,
        backprop_id: Optional[BackpropId]=None) -> None: ...


# python/context.cc
class Context:
    def get_backend(self, backend_name: str) -> Backend: ...

    @overload
    def get_device(self, device: Device) -> Device: ...

    @overload
    def get_device(self, device: str, index: int) -> Device: ...

    @overload
    def get_device(self, device: str) -> Device: ...

    def make_backprop_id(self, backprop_name: str) -> BackpropId: ...

    def release_backprop_id(self, backprop_id: BackpropId) -> None: ...

    def _check_valid_backprop_id(self, backprop_id: BackpropId) -> None: ...


class ContextScope:
    def __enter__(self) -> None: ...

    def __exit__(self, *args) -> None: ...


def get_backend(backend_name: str) -> Backend: ...

@overload
def get_device(device: Device) -> Device: ...

@overload
def get_device(device: str) -> Device: ...

@overload
def get_device(device: str, index: int) -> Device: ...

def get_default_context() -> Context: ...

def set_default_context(context: Context) -> None: ...

def get_global_default_context() -> Context: ...

def set_global_default_context(context: Context) -> None: ...


# python/device.cc
class Device:
    @property
    def backend(self) -> Backend: ...

    @property
    def context(self) -> Context: ...

    @property
    def index(self) -> int: ...

    @property
    def name(self) -> str: ...

    def synchronize(self) -> None: ...


def get_default_device() -> Device: ...

@overload
def set_default_device(device: Device) -> None: ...

@overload
def set_default_device(device: str) -> None: ...

@overload
def using_device(device: Device) -> DeviceScope: ...

@overload
def using_device(device: str) -> DeviceScope: ...

@overload
def using_device(device: str, index: int) -> DeviceScope: ...


class DeviceScope:
    def __enter__(self) -> DeviceScope: ...

    def __exit__(self, *args) -> None: ...

    @property
    def device(self) -> Device: ...


# python/error.cc
class BackendError(Exception): ...


class ChainerxError(Exception): ...


class ContextError(Exception): ...


class DeviceError(Exception): ...


class DimensionError(Exception): ...


class DtypeError(Exception): ...


class GradientCheckError(Exception): ...


class NotImplementedError(Exception): ...


# python/graph.cc
class AnyGraph: ...


class BackpropId:
    @property
    def context(self) -> Context: ...

    @property
    def name(self) -> str: ...


class BackpropScope:
    def __enter__(self) -> BackpropId: ...

    def __exit__(self, *args) -> None: ...


# python/scalar.cc
class Scalar:
    @property
    def dtype(self) -> numpy.dtype: ...

    @overload
    def __init__(self, value: bool) -> None: ...

    @overload
    def __init__(self, value: int) -> None: ...

    @overload
    def __init__(self, value: float) -> None: ...

    @overload
    def __init__(self, value: bool, dtype: Any) -> None: ...

    @overload
    def __init__(self, value: int, dtype: Any) -> None: ...

    @overload
    def __init__(self, value: float, dtype: Any) -> None: ...

    def __bool__(self) -> bool: ...

    def __float__(self) -> float: ...

    def __int__(self) -> int: ...

    def __neg__(self) -> Scalar: ...

    def __pos__(self) -> Scalar: ...

    def __repr__(self) -> str: ...

    def tolist(self) -> Any: ...


# python/array.cc
class ndarray:
    @property
    def T(self) -> ndarray: ...

    @property
    def data_ptr(self) -> int: ...

    @property
    def data_size(self) -> int: ...

    @property
    def device(self) -> Device: ...

    @property
    def dtype(self) -> numpy.dtype: ...

    @property
    def grad(self) -> Optional[ndarray]: ...

    @property
    def is_contiguous(self) -> bool: ...

    @property
    def itemsize(self) -> int: ...

    @property
    def nbytes(self) -> int: ...

    @property
    def ndim(self) -> int: ...

    @property
    def offset(self) -> int: ...

    @property
    def shape(self) -> Tuple[int, ...]: ...

    @property
    def size(self) -> int: ...

    @property
    def strides(self) -> Tuple[int, ...]: ...

    @overload
    def __add__(self, other: ndarray) -> ndarray: ...

    @overload
    def __add__(self, other: Scalar) -> ndarray: ...

    def __bool__(self) -> bool: ...

    def __float__(self) -> float: ...

    def __ge__(self, other: ndarray) -> ndarray: ...

    def __getitem__(self, key: Any) -> ndarray: ...

    @overload
    def __gt__(self, other: ndarray) -> ndarray: ...

    @overload
    def __gt__(self, other: Scalar) -> ndarray: ...

    @overload
    def __iadd__(self, other: ndarray) -> ndarray: ...

    @overload
    def __iadd__(self, other: Scalar) -> ndarray: ...

    @overload
    def __imul__(self, other: ndarray) -> ndarray: ...

    @overload
    def __imul__(self, other: Scalar) -> ndarray: ...

    def __init__(self, shape: Tuple[int, ...], dtype: Any, device: Optional[Device]=None) -> None: ...

    def __int__(self) -> int: ...

    @overload
    def __isub__(self, other: ndarray) -> ndarray: ...

    @overload
    def __isub__(self, other: Scalar) -> ndarray: ...

    @overload
    def __itruediv__(self, other: ndarray) -> ndarray: ...

    @overload
    def __itruediv__(self, other: Scalar) -> ndarray: ...

    def __le__(self, other: ndarray) -> ndarray: ...

    def __len__(self) -> int: ...

    @overload
    def __lt__(self, other: ndarray) -> ndarray: ...

    @overload
    def __lt__(self, other: Scalar) -> ndarray: ...

    @overload
    def __mul__(self, other: ndarray) -> ndarray: ...

    @overload
    def __mul__(self, other: Scalar) -> ndarray: ...

    def __neg__(self) -> ndarray: ...

    def __radd__(self, other: Scalar) -> ndarray: ...

    def __repr__(self) -> str: ...

    def __rmul__(self, other: Scalar) -> ndarray: ...

    def __rsub__(self, other: Scalar) -> ndarray: ...

    @overload
    def __sub__(self, other: ndarray) -> ndarray: ...

    @overload
    def __sub__(self, other: Scalar) -> ndarray: ...

    @overload
    def __truediv__(self, other: ndarray) -> ndarray: ...

    @overload
    def __truediv__(self, other: Scalar) -> ndarray: ...

    def argmax(self, axis: Optional[int]=None) -> ndarray: ...

    def as_grad_stopped(self, copy: bool=False) -> ndarray: ...

    def astype(self, dtype: Any, copy: bool=True) -> ndarray: ...

    def backward(
            self,
            backprop_id: Optional[BackpropId]=None,
            enable_double_backprop: bool=False) -> None: ...

    def cleargrad(self, backprop_id: Optional[BackpropId]=None) -> None: ...

    def clip(self, a_min: Optional[int], a_max: Optional[int]): ...

    def copy(self) -> ndarray: ...

    def dot(self, b: ndarray) -> ndarray: ...

    def fill(self, value: Scalar) -> None: ...

    def get_grad(self, backprop_id: Optional[BackpropId]=None) -> ndarray: ...

    @overload
    def is_backprop_required(self, backprop_id: Optional[BackpropId]=None) -> bool: ...

    @overload
    def is_backprop_required(self, backprop_id: AnyGraph) -> bool: ...

    def is_grad_required(self, backprop_id: Optional[BackpropId]=None) -> bool: ...

    @overload
    def max(self, axis: int, keepdims: bool=False) -> ndarray: ...

    @overload
    def max(self, axis: Optional[Tuple[int, ...]]=None, keepdims: bool=False) -> ndarray: ...

    def ravel(self) -> ndarray: ...

    def require_grad(self, backprop_id: Optional[BackpropId]=None) -> ndarray: ...

    @overload
    def reshape(self, newshape: Tuple[int, ...]) -> ndarray: ...

    @overload
    def reshape(self, newshape: int) -> ndarray: ...

    def set_grad(self, grad: ndarray, backprop_id: Optional[BackpropId]=None) -> None: ...

    @overload
    def squeeze(self, axis: Optional[Tuple[int, ...]]=None) -> ndarray: ...

    @overload
    def squeeze(self, axis: int) -> ndarray: ...

    @overload
    def sum(self, axis: int, keepdims: bool=False) -> ndarray: ...

    @overload
    def sum(self, axis: Optional[Tuple[int, ...]]=None, keepdims: bool=False) -> ndarray: ...

    def take(self, indices: ndarray, axis: Optional[int]=None) -> ndarray: ...

    @overload
    def to_device(self, device: Device) -> ndarray: ...

    @overload
    def to_device(self, device: str, index: int) -> ndarray: ...

    @overload
    def transpose(self, axes: Optional[Tuple[int, ...]]=None) -> ndarray: ...

    @overload
    def transpose(self, axes: int) -> ndarray: ...

    def view(self) -> ndarray: ...

# python/routines.cc
@overload
def add(x1: ndarray, x2: ndarray) -> ndarray: ...

@overload
def add(x1: ndarray, x2: Scalar) -> ndarray: ...

@overload
def add(x1: Scalar, x2: ndarray) -> ndarray: ...

@overload
def amax(a: ndarray, axis: int, keepdims: bool=False) -> ndarray: ...

@overload
def amax(a: ndarray, axis: Optional[Tuple[int, ...]]=None, keepdims: bool=False) -> ndarray: ...

def arange(
        start: Scalar,
        stop: Optional[Scalar]=None,
        step: Optional[Scalar]=None,
        dtype: Optional[Any]=None,
        device: Optional[Device]=None) -> ndarray: ...

def argmax(a: ndarray, axis: Optional[int]=None) -> ndarray: ...

def array(object: Any, dtype: Optional[Any]=None, copy: bool=True, device: Optional[Device]=None) -> ndarray: ...

def asarray(object: Any, dtype: Optional[Any]=None, device: Optional[Device]=None) -> ndarray: ...

def ascontiguousarray(a: Any, dtype: Optional[Any]=None, device: Optional[Device]=None) -> ndarray: ...

def asscalar(a: ndarray) -> Any: ...

def average_pool(x: ndarray, ksize: Any, stride: Any=None, pad: Any=0, pad_mode: str='ignore') -> ndarray: ...

def backprop_scope(backprop_name: str, context: Any=None) -> BackpropScope: ...

def batch_norm(
        x: ndarray,
        gamma: ndarray,
        beta: ndarray,
        running_mean: ndarray,
        running_var: ndarray,
        eps: Scalar=...,
        decay: Scalar=...,
        axis: Optional[List[int]]=None) -> ndarray: ...


def broadcast_to(array: ndarray, shape: tuple) -> ndarray: ...

def concatenate(arrays: List[ndarray], axis: Optional[int]=0) -> ndarray: ...

def context_scope(context: Context) -> ContextScope: ...

def conv(
        x: ndarray,
        w: ndarray,
        b: Optional[ndarray]=None,
        stride: Union[int, Tuple[int, ...]]=1,
        pad: Union[int, Tuple[int, ...]]=0,
        cover_all: bool=False) -> ndarray: ...

def conv_transpose(
        x: ndarray,
        w: ndarray,
        b: Optional[ndarray]=None,
        stride: Union[int, Tuple[int, ...]]=1,
        pad: Union[int, Tuple[int, ...]]=0,
        outsize: Optional[tuple]=None) -> ndarray: ...

def copy(a: ndarray) -> ndarray: ...

def diag(v: ndarray, k: int=0, device: Optional[Device]=None) -> ndarray: ...

def diagflat(v: ndarray, k: int=0, device: Optional[Device]=None) -> ndarray: ...

@overload
def divide(x1: ndarray, x2: ndarray) -> ndarray: ...

@overload
def divide(x1: ndarray, x2: Scalar) -> ndarray: ...

@overload
def divide(x1: Scalar, x2: ndarray) -> ndarray: ...

def dot(a: ndarray, b: ndarray) -> ndarray: ...

@overload
def empty(
        shape: int,
        dtype: Optional[Any]=None,
        device: Optional[Device]=None) -> ndarray: ...

@overload
def empty(
        shape: Tuple[int, ...],
        dtype: Optional[Any]=None,
        device: Optional[Device]=None) -> ndarray: ...

def empty_like(a: ndarray, device: Optional[Device]=None) -> ndarray: ...

def equal(x1: ndarray, x2: ndarray) -> ndarray: ...

def exp(x: ndarray) -> ndarray: ...

def eye(N: int,
        M: Optional[int]=None,
        k: int=0,
        dtype: Any='float64',
        device: Optional[Device]=None) -> ndarray: ...

def fixed_batch_norm(
        x: ndarray,
        gamma: ndarray,
        beta: ndarray,
        mean: ndarray,
        var: ndarray,
        eps: Scalar=...,
        axis: Optional[List[int]]=None) -> ndarray: ...

def frombuffer(
        buffer: Any,
        dtype: Any='float32',
        count: int=-1,
        offset: int=0,
        device: Optional[Device]=None) -> ndarray: ...

@overload
def full(shape: int, fill_value: Scalar, dtype: Any, device: Optional[Device]=None) -> ndarray: ...

@overload
def full(shape: Tuple[int, ...], fill_value: Scalar, dtype: Any, device: Optional[Device]=None) -> ndarray: ...

@overload
def full(shape: int, fill_value: Scalar, device: Optional[Device]=None) -> ndarray: ...

@overload
def full(shape: Tuple[int, ...], fill_value: Scalar, device: Optional[Device]=None) -> ndarray: ...

def full_like(a: ndarray, fill_value: Scalar, device: Optional[Device]=None) -> ndarray: ...

def greater(x1: ndarray, x2: ndarray) -> ndarray: ...

def greater_equal(x1: ndarray, x2: ndarray) -> ndarray: ...

def identity(n: int, dtype: Optional[Any]=None, device: Optional[Device]=None) -> ndarray: ...

def is_available(): ...

def isinf(x: ndarray) -> ndarray: ...

def isnan(x: ndarray) -> ndarray: ...

def less(x1: ndarray, x2: ndarray) -> ndarray: ...

def less_equal(x1: ndarray, x2: ndarray) -> ndarray: ...

def linear(x: ndarray, w: ndarray, b: Optional[ndarray]=None, n_batch_axes: int=1) -> ndarray: ...

def linspace(
        start: Scalar,
        stop: Scalar,
        num: int=50,
        endpoint: bool=True,
        dtype: Optional[Any]=None,
        device: Optional[Device]=None) -> ndarray: ...

def log(x: ndarray) -> ndarray: ...

@overload
def log_softmax(x: ndarray, axis: Optional[List[int]]=None) -> ndarray: ...

@overload
def log_softmax(x: ndarray, axis: int) -> ndarray: ...

def logical_not(x: ndarray) -> ndarray: ...

@overload
def logsumexp(x: ndarray, axis: Optional[List[int]]=None, keepdims: bool=False) -> ndarray: ...

@overload
def logsumexp(x: ndarray, axis: int, keepdims: bool=False) -> ndarray: ...

def max_pool(
        x: ndarray,
        ksize: Any,
        stride: Union[int, Tuple[int, ...]]=None,
        pad: Union[int, Tuple[int, ...]]=0,
        cover_all: bool=False) -> ndarray: ...

@overload
def maximum(x1: ndarray, x2: Scalar) -> ndarray: ...

@overload
def maximum(x1: Scalar, x2: ndarray) -> ndarray: ...

@overload
def multiply(x1: ndarray, x2: ndarray) -> ndarray: ...

@overload
def multiply(x1: ndarray, x2: Scalar) -> ndarray: ...

@overload
def multiply(x1: Scalar, x2: ndarray) -> ndarray: ...

def negative(x: ndarray) -> ndarray: ...

def not_equal(x1: ndarray, x2: ndarray) -> ndarray: ...

@overload
def ones(shape: Tuple[int, ...], dtype: Optional[Any]=None, device: Optional[Device]=None) -> ndarray: ...

@overload
def ones(shape: int, dtype: Optional[Any]=None, device: Optional[Device]=None) -> ndarray: ...

def ones_like(a: ndarray, device: Optional[Device]=None) -> ndarray: ...

@overload
def reshape(a: ndarray, newshape: Tuple[int, ...]) -> ndarray: ...

@overload
def reshape(a: ndarray, newshape: int) -> ndarray: ...

@overload
def split(ary: ndarray, indices_or_sections: List[int], axis: int=0) -> List[ndarray]: ...

@overload
def split(ary: ndarray, indices_or_sections: int, axis: int=0) -> List[ndarray]: ...

def sqrt(x: ndarray) -> ndarray: ...

@overload
def squeeze(a: ndarray, axis: Optional[List[int]]=None) -> ndarray: ...

@overload
def squeeze(a: ndarray, axis: int) -> ndarray: ...

def stack(arrays: List[ndarray], axis: int=0) -> ndarray: ...

@overload
def subtract(x1: ndarray, x2: ndarray) -> ndarray: ...

@overload
def subtract(x1: ndarray, x2: Scalar) -> ndarray: ...

@overload
def subtract(x1: Scalar, x2: ndarray) -> ndarray: ...

@overload
def sum(a: ndarray, axis: Optional[Tuple[int, ...]]=None, keepdims: bool=False) -> ndarray: ...

@overload
def sum(a: ndarray, axis: int, keepdims: bool=False) -> ndarray: ...

def take(a: ndarray, indices: ndarray, axis: Optional[int]) -> ndarray: ...

def tanh(x: ndarray) -> ndarray: ...

def to_numpy(array: ndarray, copy: bool=True) -> numpy.ndarray: ...

@overload
def transpose(a: ndarray, axes: Optional[Tuple[int, ...]]=None) -> ndarray: ...

@overload
def transpose(a: ndarray, axes: int) -> ndarray: ...

@overload
def zeros(shape: Tuple[int, ...], dtype: Optional[Any]=None, device: Optional[Device]=None) -> ndarray: ...

@overload
def zeros(shape: int, dtype: Optional[Any]=None, device: Optional[Device]=None) -> ndarray: ...

def zeros_like(a: ndarray, device: Optional[Device]=None) -> ndarray: ...


# python/chainer_interop.cc
def _function_node_forward(
        function_node: function_node.FunctionNode,
        inputs: Sequence[ndarray],
        outputs: Sequence[ndarray],
        input_indexes_to_retain: Sequence[int],
        output_indexes_to_retain: Sequence[int]) -> None: ...
